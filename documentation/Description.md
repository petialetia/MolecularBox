# Полное описание "Коробки с молекулами"

## Идея:

Есть некое ограниченное тело, внутри которого перемещаются и взаимодействуют друг с другом молекулы. Природа взаимодействий, потенциально, любая: механические столкновения, передача тепла, быть может даже "химическая", когда одни молекулы при столкновении с другими порождают новые. Соответственно, необходимо просчитывать и отрисовывать положения молекул.

## Планируется реализация двух способов просчёта: 

### 1) Пошаговый:

В начале проверяются все взаимодействия, не должны ли они случится, которые должны - случаются, после чего время отматывается на некоторый шаг вперёд, вновь проверяются все взаимодействия, делаются все случившиеся, время мотается вперёд и т.д.

### 2) Предсказывающий:

Взаимодействия молекул предсказываются и обрабатываются только тогда, когда они точно произошли, после обработки перепредсказываются взаимодействия лишь для только что провзаимодействовавших молекул. По сравнению с пошаговым методом имеет ряд преимуществ и недостатков.

## Сравнение способов просчёта: 

#### Плюсы предсказывающего подхода:

а) Точность - поскольку взаимодействие будет обработано сразу как только оно возникнет, не случится, к примеру, проникновения двух объектов друг в друга, когда они должны абсолютно упруго отскакивать.

б) Значительно уменьшает количество проверок на событие при не очень частом их возникновении.

#### Минусы предсказывающего подхода: 

а) Такой способ валидный только для непостоянных взаимодействий, скажем, обработать таким способом гравитационные взаимодействия не получится (сталкиваемся с фундаментальной проблемой физики, известной как проблема трёх тел).

б) Требует хранить время, через которое произойдёт каждое событие, а также быстро искать среди них минимальное значение.

## Interactions (они же взаимодействия):

При проектировании применён паттерн "наблюдатель", здесь в качестве получателей выступают молекулы, а в качестве издателей - взаимодействия. Взаимодействия сами могут узнать, произошли они или нет, и при этом сами делают действия над молекулами ("уведомляя" их таким образом о случившемся событии).

Поскольку не все взаимодействия можно просчитать вторым методом, предсказываемые события наследуются от обычных.

### Отдельного упоминания заслуживает DrawningInteraction:

Interaction-ы создаются по одному на каждый набор взаимодействующих молекул. Скажем, нет одного всеобъемлющего коллизионного взаимодействия, которому подвержены все объекты симуляции, каждая пара молекул, которые должны реагировать на взаимное проникновение, создаёт своё взаимодействие. Что также означает, что если по каким-то причинам пользователь решит, что 2 конкретные молекулы не должны реагировать на проникновение друг в друга, то он не создаст такое взаимодействие. Пусть это и означает, что коллизионных взаимодействий у большинства пользователей будет O(n^2), зато система максимально гибка.

Всё то, что написано выше, правда для всех взаимодействий, кроме одного - взаимодействия рисования. DrawningInteraction глобально один на все молекулы. У этого решения есть один недостаток, который, быть может, вовсе и недостаток, и очень много преимуществ. Тот самый недостаток - потеря гибкости, все молекулы, которые должны рисоваться, рисуются единовременно. Собственно спрашивается - а какой резон им рисоваться не единовременно? Так ли нам важно дать свободу рисовать все молекулы когда вздумается пользователю (быть может даже, разные молекулы с разной частотой), взамен приобретя следующие проблемы:

1) Неясно, когда нужно очищать экран, а без этого старые изображения молекул будут наслаиваться друг на друга.

2) Если делать для каждой молекулы своё взаимодействия рисования, то их, в большинстве случаев, будет O(n), это увеличивает количество проверок, а значит замедляет симуляцию.

Кроме этого, единый DrawningInteraction решает ещё одну проблему, которой надо уделить особое внимание.

На данный момент скорость работы симуляции привязана к мощности компьютера пользователя, чем он мощнее, тем быстрее будет для него работать симуляция. Да, конечно, если у тебя локально симуляция слишком быстра, ничего не мешает увеличить точность или частоту обновления, или если наоборот слишком медленна, то уменьшить точность и частоту обновления. В рамках текущей задачи такой подход в целом допустим, но если мы захотим уйти даже немного в сторону, то это может стать неприемлемым. Корректность, точность симуляции в общем случае не должна быть привязана к мощности компьютера. 

Эту проблему спешит решить DrawningInteraction. С его помощью можно будет в недалёком будущем сделать следующее: поставить желаемое количество отрисовок в секунду (fps), и если отрисовки происходят слишком быстро, то ждать некоторое кол-во времени до следующей отрисовки. Поскольку рисование происходит регулярно и с точки зрения времени внутри симуляции, это будет значить, что симуляция остановится на некоторое время, чтобы пользователь смог увидеть её текущее состояние.